<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>决策树 | ExampleSite</title>
<meta name=keywords content="Theory,Decision Tree,Regression Decision Tree">
<meta name=description content="树即是人，人即是树
参考：
 西瓜书第4章 决策树 决策树系列（一）——基础知识回顾与总结
 1. 基本流程 在日常生活中其实我们都可能在使用决策树算法，只是你没有这个概念，比如说，在这个看脸的时代，你在妹子心中的状态可以用下图描述
{% asset_img tree.png 简单决策树 %}
这样就完成了一个三分类决策树，每一个判断节点都是一个属性，每个节点的分支都是该属性的属性值。
 决策树学习基本算法
输入：训练集$D = { (\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), &mldr;, (\boldsymbol{x}_m, y_m) }$；
过程：函数$TreeGenerate(D, A)$
01：生成结点$node$；
02：$if$ $D$中样本全属于同一类别$C$ $then$
03： 将$node$标记为$C$类叶结点；$return$
04：$end$ $if$
05：$if$ $A = \emptyset$ $OR$ $D$ 中样本在$A$上的取值相同 $then$
06： 将$node$标记为叶结点，其类别标记为$D$中样本数最多的类；$return$
07：$end$ $if$
08：从$A$中选择最优化分属性$a_k$；
09：$for$ $a_k$的每一个值$a^v_k$ $do$
10： 为$node$生成一个分支；令$D_v$表示$D$中在$a_k$上取值为$a_k^v$的样本子集；
11： $if$ $D_v$为空 $then$
12： 将分支结点标记为叶结点，其标记类别为$D$中样本最多的类；$return$
13： $else$
14： 以$TreeGenerate(D_v, A \setminus {a_k })$为分支结点">
<meta name=author content="Me">
<link rel=canonical href=https://zhuantou233.github.io/posts/2018-11-07-%E5%86%B3%E7%AD%96%E6%A0%91/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhuantou233.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhuantou233.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhuantou233.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhuantou233.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhuantou233.github.io/favicon.ico>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.90.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script>MathJax={tex:{inlineMath:[["$","$"]],processEscapes:!0,processEnvironments:!0},displayMath:[["$$","$$"]],svg:{fontCache:"global"}}</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="决策树">
<meta property="og:description" content="树即是人，人即是树
参考：
 西瓜书第4章 决策树 决策树系列（一）——基础知识回顾与总结
 1. 基本流程 在日常生活中其实我们都可能在使用决策树算法，只是你没有这个概念，比如说，在这个看脸的时代，你在妹子心中的状态可以用下图描述
{% asset_img tree.png 简单决策树 %}
这样就完成了一个三分类决策树，每一个判断节点都是一个属性，每个节点的分支都是该属性的属性值。
 决策树学习基本算法
输入：训练集$D = { (\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), &mldr;, (\boldsymbol{x}_m, y_m) }$；
过程：函数$TreeGenerate(D, A)$
01：生成结点$node$；
02：$if$ $D$中样本全属于同一类别$C$ $then$
03： 将$node$标记为$C$类叶结点；$return$
04：$end$ $if$
05：$if$ $A = \emptyset$ $OR$ $D$ 中样本在$A$上的取值相同 $then$
06： 将$node$标记为叶结点，其类别标记为$D$中样本数最多的类；$return$
07：$end$ $if$
08：从$A$中选择最优化分属性$a_k$；
09：$for$ $a_k$的每一个值$a^v_k$ $do$
10： 为$node$生成一个分支；令$D_v$表示$D$中在$a_k$上取值为$a_k^v$的样本子集；
11： $if$ $D_v$为空 $then$
12： 将分支结点标记为叶结点，其标记类别为$D$中样本最多的类；$return$
13： $else$
14： 以$TreeGenerate(D_v, A \setminus {a_k })$为分支结点">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhuantou233.github.io/posts/2018-11-07-%E5%86%B3%E7%AD%96%E6%A0%91/"><meta property="og:image" content="https://zhuantou233.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-11-07T16:32:20+00:00">
<meta property="article:modified_time" content="2018-11-07T16:32:20+00:00"><meta property="og:site_name" content="ExampleSite">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhuantou233.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="决策树">
<meta name=twitter:description content="树即是人，人即是树
参考：
 西瓜书第4章 决策树 决策树系列（一）——基础知识回顾与总结
 1. 基本流程 在日常生活中其实我们都可能在使用决策树算法，只是你没有这个概念，比如说，在这个看脸的时代，你在妹子心中的状态可以用下图描述
{% asset_img tree.png 简单决策树 %}
这样就完成了一个三分类决策树，每一个判断节点都是一个属性，每个节点的分支都是该属性的属性值。
 决策树学习基本算法
输入：训练集$D = { (\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), &mldr;, (\boldsymbol{x}_m, y_m) }$；
过程：函数$TreeGenerate(D, A)$
01：生成结点$node$；
02：$if$ $D$中样本全属于同一类别$C$ $then$
03： 将$node$标记为$C$类叶结点；$return$
04：$end$ $if$
05：$if$ $A = \emptyset$ $OR$ $D$ 中样本在$A$上的取值相同 $then$
06： 将$node$标记为叶结点，其类别标记为$D$中样本数最多的类；$return$
07：$end$ $if$
08：从$A$中选择最优化分属性$a_k$；
09：$for$ $a_k$的每一个值$a^v_k$ $do$
10： 为$node$生成一个分支；令$D_v$表示$D$中在$a_k$上取值为$a_k^v$的样本子集；
11： $if$ $D_v$为空 $then$
12： 将分支结点标记为叶结点，其标记类别为$D$中样本最多的类；$return$
13： $else$
14： 以$TreeGenerate(D_v, A \setminus {a_k })$为分支结点">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhuantou233.github.io/posts/"},{"@type":"ListItem","position":2,"name":"决策树","item":"https://zhuantou233.github.io/posts/2018-11-07-%E5%86%B3%E7%AD%96%E6%A0%91/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"决策树","name":"决策树","description":"树即是人，人即是树\n参考：\n 西瓜书第4章 决策树 决策树系列（一）——基础知识回顾与总结\n 1. 基本流程 在日常生活中其实我们都可能在使用决策树算法，只是你没有这个概念，比如说，在这个看脸的时代，你在妹子心中的状态可以用下图描述\n{% asset_img tree.png 简单决策树 %}\n这样就完成了一个三分类决策树，每一个判断节点都是一个属性，每个节点的分支都是该属性的属性值。\n 决策树学习基本算法\n输入：训练集$D = { (\\boldsymbol{x}_1, y_1), (\\boldsymbol{x}_2, y_2), \u0026hellip;, (\\boldsymbol{x}_m, y_m) }$；\n过程：函数$TreeGenerate(D, A)$\n01：生成结点$node$；\n02：$if$ $D$中样本全属于同一类别$C$ $then$\n03： 将$node$标记为$C$类叶结点；$return$\n04：$end$ $if$\n05：$if$ $A = \\emptyset$ $OR$ $D$ 中样本在$A$上的取值相同 $then$\n06： 将$node$标记为叶结点，其类别标记为$D$中样本数最多的类；$return$\n07：$end$ $if$\n08：从$A$中选择最优化分属性$a_k$；\n09：$for$ $a_k$的每一个值$a^v_k$ $do$\n10： 为$node$生成一个分支；令$D_v$表示$D$中在$a_k$上取值为$a_k^v$的样本子集；\n11： $if$ $D_v$为空 $then$\n12： 将分支结点标记为叶结点，其标记类别为$D$中样本最多的类；$return$\n13： $else$\n14： 以$TreeGenerate(D_v, A \\setminus {a_k })$为分支结点","keywords":["Theory","Decision Tree","Regression Decision Tree"],"articleBody":"树即是人，人即是树\n参考：\n 西瓜书第4章 决策树 决策树系列（一）——基础知识回顾与总结\n 1. 基本流程 在日常生活中其实我们都可能在使用决策树算法，只是你没有这个概念，比如说，在这个看脸的时代，你在妹子心中的状态可以用下图描述\n{% asset_img tree.png 简单决策树 %}\n这样就完成了一个三分类决策树，每一个判断节点都是一个属性，每个节点的分支都是该属性的属性值。\n 决策树学习基本算法\n输入：训练集$D = { (\\boldsymbol{x}_1, y_1), (\\boldsymbol{x}_2, y_2), …, (\\boldsymbol{x}_m, y_m) }$；\n过程：函数$TreeGenerate(D, A)$\n01：生成结点$node$；\n02：$if$ $D$中样本全属于同一类别$C$ $then$\n03： 将$node$标记为$C$类叶结点；$return$\n04：$end$ $if$\n05：$if$ $A = \\emptyset$ $OR$ $D$ 中样本在$A$上的取值相同 $then$\n06： 将$node$标记为叶结点，其类别标记为$D$中样本数最多的类；$return$\n07：$end$ $if$\n08：从$A$中选择最优化分属性$a_k$；\n09：$for$ $a_k$的每一个值$a^v_k$ $do$\n10： 为$node$生成一个分支；令$D_v$表示$D$中在$a_k$上取值为$a_k^v$的样本子集；\n11： $if$ $D_v$为空 $then$\n12： 将分支结点标记为叶结点，其标记类别为$D$中样本最多的类；$return$\n13： $else$\n14： 以$TreeGenerate(D_v, A \\setminus {a_k })$为分支结点\n15： $end$ $if$\n16：$end$ $for$\n输出：以$node$为根结点的一棵决策树\n 递归生成决策树有三种情形会导致递归返回：\n 当前结点包含的样本全属于同一类别，无需划分； 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分； 当前结点包含的样本集合为空，不能划分。  2. 划分选择 决策树学习的关键在第8行，即如何选择最优划分属性。一般来说，我们希望分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”也来越高（如何衡量“纯度”，有不同的算法）。\n2.1 信息增益 假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k = 1,2,…,|\\mathbb{Y}|)$，则$D$的信息熵定义为\n$$ Ent(D) = -\\sum^{|\\mathbb{Y}|}_{k=1}p_k\\log_2p_k $$\n$Ent(D)$的值越小，则$D$的纯度越高。\n假定离散属性$a$有$V$个可能的取值${ a^1, a^2, …,a^V }$，若使用$a$来对样本集合$D$进行划分，则会产生$V$个分支结点，其中第$v$个分支结点包含了$D$中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。则可以计算用属性$a$对$D$进行划分所获得的信息增益\n$$ Gain(D, a) = Ent(D) - \\sum^V_{v=1}\\frac{|D^v|}{|D|}Ent(D^v) $$\n一般而言，信息增益越大，则使用属性$a$来进行划分所获得的纯度提升越大。因此，在第8行使用属性$a_k = \\underset{a \\in A}{\\arg \\max Gain(D, a)}$。这就是$ID3$决策树学习算法的划分准则。\n2.2 增益率 利用信息增益作为划分准则可能会带来另一问题，即对可取值数目较多的属性有所偏好，比如说若一个属性有10个属性值，而另一个属性只有3个属性值，此时经过计算很大程度上10个属性值的属性带来的信息增益会大于另一个。为减少这种偏好可能带来的不利影响，$C4.5$决策树算法使用增益率作为划分准则\n$$ Gain_ratio(D, a) = \\frac{Gain(D,a)}{IV(a)} \\ IV(a) = -\\sum^V_{v=1}\\frac{|D^v|}{|D|} \\log_2\\frac{|D^v|}{|D|} $$\n$IV(a)$称为属性$a$的固有值，若属性$a$的取值数目越多，则$IV(a)$的值通常会越大。\n与此同时$C4.5$算法具体流程并不是直接选择增益率最高的属性，而是先从候选属性中选择信息增益高于平均水平的属性，再从中选择增益率高的。\n2.3 基尼指数 $CART$决策树（可用于分类和回归）使用基尼指数选择划分属性\n$$ Gini(D) = \\sum^{|\\mathbb{Y}|}{k=1}\\sum{k' \\neq k}p_kp_{k'} \\ = 1- \\sum^{|\\mathbb{Y}|}_{k=1}p_k^2 $$\n$Gini(D)$反映了从数据集$D$中随机抽取两个样本，其类别标记不一致的概率。因此，$Gini(D)$越小，则数据集$D$纯度越高。\n则对应属性$a$的基尼指数定义为\n$$ Gini_index(D, a) = \\sum^V_{v=1}\\frac{|D^v|}{|D|}Gini(D^v) $$\n我们选择使得划分后基尼指数最小的属性作为最优属性，即\n$$ a_k = \\underset{a \\in A}{\\arg \\min}Gini_index(D, a) $$\n3. 剪枝处理 剪枝是对付过拟合的主要手段，主要方式是删除一些分支，基本策略有两种，预剪枝和后剪枝。\n 预剪枝是在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分当前结点并标记为叶结点； 后剪枝是先从数据集生成一棵完整的决策树，然后自底向上对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将子树替换为叶结点。  如何判断泛化性能，我们使用验证集进行评估。\n3.1 预剪枝 {% asset_img precut.png 预剪枝 %}\n 根据划分准则选择最优划分属性； 计算不对当前最优属性划分的条件下验证集的准确率； 计算对当前最优属性划分后验证集的准确率； 比较上面两步的值，若划分后的准确率不大于划分前，则放弃使用该属性划分。  优劣：\n 预剪枝是基于贪心算法的，必然存在继续划分可能带来泛化性能提升的可能性，使用预剪枝导致永远无法展开这些分支； 预剪枝降低过拟合的风险，减少了训练开销。  3.2 后剪枝 {% asset_img backcut.png 后剪枝 %}\n 根据训练集生成完整的决策树； 计算当前决策树在验证集上的准确率； 自底向上考虑某个属性，计算将当前属性替换为叶结点（取最多的类别作为叶结点标记）后的验证集准确率； 比较上面两步的值，若剪枝后的准确率不大于剪枝前的，则放弃使用该属性划分。  优劣：\n 后剪枝保留的分支较预剪枝多，所以欠拟合风险小，泛化性能优于预剪枝； 自底向上的过程导致训练开销远大于预剪枝。  4. 连续与缺失值 4.1 连续值处理 对于连续值，最简单的策略是采用二分法，即将属性$a$的属性值基于$t$划分为两个阵营$D_t^-$和$D_t^+$，如何确定$t$的值才能使该划分为最优化分，显然，$t$的取值在$[a^i, a^{i+1})$之间都是等效的，那么我们可以参照插队的方式取$t$的所有可能值，再从中选取最优点。\n对于有$n$个属性值的连续属性$a$，$t$的候选划分点集和\n$$ T_a = { \\frac{a^i + a^{i+1}}{2}|1 \\leqslant i \\leqslant n-1 } $$\n通过对信息增益表达式的改造\n$$ Gain(D, a) = \\underset{t \\in T_a}{\\max} Gain(D, a, t) \\ = \\underset{t \\in T_a}{\\max} Ent(D) - \\sum_{\\lambda \\in { -,+ }}\\frac{|D^{\\lambda}_t|}{|D|}Ent(D_t^{\\lambda}) $$\n需注意的是，与离散属性不同，若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性。\n4.2 缺失值处理 样本不完整，那么该样本应该怎样划分呢。\n问题等价于\n 如何在属性缺失的情况下进行划分属性选择？ 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？  比较简单的方式是根据数据集$D$中在属性$a$上没有缺失值的样本来对属性$a$进行划分。\n 对问题（1），令$\\tilde{D}$表示$D$在属性$a$上没有缺失值的样本子集， 假定属性$a$有$V$个可取值${ a^1, a^2,…,a^V }$， 令$\\tilde{D}^v$表示$\\tilde{D}$中在属性$a$上取值为$a^v$的样本子集， $\\tilde{D}k$表示$\\tilde{D}$中属于第$k$类（$k = 1, 2,…,|\\mathbb{Y}|$）的样本子集，则显然有$\\tilde{D} = \\bigcup{k=1}^{|\\mathbb{Y}|}\\tilde{D}k = \\bigcup{v=1}^{|V|}\\tilde{D}^v$。 假定为每个样本$\\boldsymbol{x}$初始化一个权重$w_{\\boldsymbol{x}}$（初始值全为1），并定义\n$$ \\rho = \\frac{\\sum_{\\boldsymbol{x}\\in \\tilde{D}}w_{\\boldsymbol{x}}}{\\sum_{\\boldsymbol{x}\\in D}w_{\\boldsymbol{x}}} \\ \\tilde{p}k = \\frac{\\sum{\\boldsymbol{x}\\in \\tilde{D}k}w{\\boldsymbol{x}}}{\\sum_{\\boldsymbol{x}\\in \\tilde{D}}w_{\\boldsymbol{x}}} \\ \\tilde{r}v = \\frac{\\sum{\\boldsymbol{x}\\in \\tilde{D}^v}w_{\\boldsymbol{x}}}{\\sum_{\\boldsymbol{x}\\in \\tilde{D}}w_{\\boldsymbol{x}}} $$\n对属性$a$来说，$\\rho$表示无缺失值样本所占的比例，$\\tilde{p}_k$表示无缺失值样本中第$k$类所占的比例，$\\tilde{r}v$则表示无缺失值样本在属性$a$上取值$a^v$的样本所占的比例。显然$\\sum^{|\\mathbb{Y}|}{k=1}\\tilde{p}k=1,\\sum^V{v=1}\\tilde{r}_v=1$。\n基于上述定义，信息增益计算式可推广为\n$$ Gain(D, a) = \\rho \\times Gain(\\tilde{D}, a) \\ = \\rho \\times { Ent(\\tilde{D}) - \\sum^V_{v=1}\\tilde{r}_vEnt(\\tilde{D}^v) } $$\n其中\n$$ Ent(\\tilde{D}) = - \\sum^{|\\mathbb{Y}|}_{k=1}\\tilde{p}_k\\log_2\\tilde{p}_k $$\n 对问题（2）,若样本$\\boldsymbol{x}$在划分属性$a$上的取值已知，则将$\\boldsymbol{x}$划入与其取值对应的子结点，且样本权值保持为$w_{\\boldsymbol{x}}$。 若样本$\\boldsymbol{x}$在划分属性$a$上的取值未知，则将$\\boldsymbol{x}$同时划入所有子结点，且样本权值在与属性$a^v$对应的子结点中调整为$\\tilde{r} \\cdot w_{\\boldsymbol{x}}$； 直观地看，这就是让同一个样本以不同的概率划入到不同的子结点中去。\n5. 多变量决策树 使用单属性作为划分结点，我们得到的决策树的分类边界是平行于该属性对应的轴。\n{% asset_img tree1.png 决策树对应分类边界 %}\n但在现实任务中，我们希望分类边界尽可能平滑，越平滑意味着每个结点包含的分类标准越复杂，需要的属性组合就越多，所以我们希望能以局部线性拟合平滑曲线，这就是多变量决策树\n{% asset_img tree3.png 决策树对复杂分类边界的分段近似 %}\n在多变量决策树中，每个非叶结点不再是仅对某个属性，而是对属性的线性组合进行测试；换言之，每个非叶结点是一个形如$\\sum^d_{i=1}w_ia_i=t$的线性分类器，其中$w_i$是属性$a_i$的权重，$w_i,t$可在该结点所含的样本集和属性集上学得。于是，多变量决策树的训练过程就不是寻找最优划分属性，而是建立一个合适的线性分类器。\n{% asset_img tree2.png 多变量决策树对应的分类边界 %}\n6. 回归树 {% asset_img 0.png %}\n分类决策树处理的是分类问题，其特点是target是label标签，而标签是一个有限集，因此决策树的构建需要在叶结点判断标签，最终也只需要判断准确率即可，分类节点使用信息增益相关的算法即可； 回归树处理的是回归问题，即最终的目标是一个预测值，而我们的训练数据的真实值可以说是无穷多的，因此只能用误差损失来衡量，比如用平方误差衡量单个样本的误差。而每个结点（不只是叶结点）都对应一个预测值，这个预测值的大小是被分配到这个结点的所有样本的真实值的均值，如何选择最优属性以及最优划分阈值可以参考上面4. 连续与缺失值。\n{% asset_img 1.png %}\n7. 思考  决策树是最接近人类思考的最简单的模型，讲道理在大多数情况下，我们所做的每一个行为都是基于各种细小属性的决策，那么是否有一种复杂多变量决策树可以动态的描述一个人或者生物的行为呢，与此同时，每一个分类结点的权重也是一个变量，其收到其他因素的影响。显然，这种想法会导致维度爆炸。 换一种思路，我们基于某种主干决策树做大多数决策，同时存在偏差决策树，偏差决策树构成森林，根据主干与偏差的相互叠加，我们完成其他的行为决策。 基于决策树的其他算法框架在分类任务中具有极好的效果，比如XGBoost、GBDT、Random Forest，接下来会思考这些算法。  ","wordCount":"352","inLanguage":"en","datePublished":"2018-11-07T16:32:20Z","dateModified":"2018-11-07T16:32:20Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhuantou233.github.io/posts/2018-11-07-%E5%86%B3%E7%AD%96%E6%A0%91/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"https://zhuantou233.github.io/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhuantou233.github.io/ accesskey=h title="Home (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhuantou233.github.io/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://zhuantou233.github.io/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://zhuantou233.github.io/series/ title=series>
<span>series</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhuantou233.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zhuantou233.github.io/posts/>Posts</a></div>
<h1 class=post-title>
决策树
</h1>
<div class=post-meta><span title="2018-11-07 16:32:20 +0000 UTC">November 7, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2018-11-07-%e5%86%b3%e7%ad%96%e6%a0%91.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#1-%e5%9f%ba%e6%9c%ac%e6%b5%81%e7%a8%8b aria-label="1. 基本流程">1. 基本流程</a></li>
<li>
<a href=#2-%e5%88%92%e5%88%86%e9%80%89%e6%8b%a9 aria-label="2. 划分选择">2. 划分选择</a><ul>
<li>
<a href=#21-%e4%bf%a1%e6%81%af%e5%a2%9e%e7%9b%8a aria-label="2.1 信息增益">2.1 信息增益</a></li>
<li>
<a href=#22-%e5%a2%9e%e7%9b%8a%e7%8e%87 aria-label="2.2 增益率">2.2 增益率</a><ul>
<li>
<a href=#23-%e5%9f%ba%e5%b0%bc%e6%8c%87%e6%95%b0 aria-label="2.3 基尼指数">2.3 基尼指数</a></li></ul>
</li></ul>
</li>
<li>
<a href=#3-%e5%89%aa%e6%9e%9d%e5%a4%84%e7%90%86 aria-label="3. 剪枝处理">3. 剪枝处理</a><ul>
<li>
<a href=#31-%e9%a2%84%e5%89%aa%e6%9e%9d aria-label="3.1 预剪枝">3.1 预剪枝</a></li>
<li>
<a href=#32-%e5%90%8e%e5%89%aa%e6%9e%9d aria-label="3.2 后剪枝">3.2 后剪枝</a></li></ul>
</li>
<li>
<a href=#4-%e8%bf%9e%e7%bb%ad%e4%b8%8e%e7%bc%ba%e5%a4%b1%e5%80%bc aria-label="4. 连续与缺失值">4. 连续与缺失值</a><ul>
<li>
<a href=#41-%e8%bf%9e%e7%bb%ad%e5%80%bc%e5%a4%84%e7%90%86 aria-label="4.1 连续值处理">4.1 连续值处理</a></li>
<li>
<a href=#42-%e7%bc%ba%e5%a4%b1%e5%80%bc%e5%a4%84%e7%90%86 aria-label="4.2 缺失值处理">4.2 缺失值处理</a></li></ul>
</li>
<li>
<a href=#5-%e5%a4%9a%e5%8f%98%e9%87%8f%e5%86%b3%e7%ad%96%e6%a0%91 aria-label="5. 多变量决策树">5. 多变量决策树</a></li>
<li>
<a href=#6-%e5%9b%9e%e5%bd%92%e6%a0%91 aria-label="6. 回归树">6. 回归树</a></li>
<li>
<a href=#7-%e6%80%9d%e8%80%83 aria-label="7. 思考">7. 思考</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p><strong>树即是人，人即是树</strong></p>
<p>参考：</p>
<blockquote>
<p>西瓜书第4章 决策树
<a href=http://www.cnblogs.com/yonghao/p/5061873.html>决策树系列（一）——基础知识回顾与总结</a></p>
</blockquote>
<h2 id=1-基本流程>1. 基本流程<a hidden class=anchor aria-hidden=true href=#1-基本流程>#</a></h2>
<p>在日常生活中其实我们都可能在使用决策树算法，只是你没有这个概念，比如说，在这个看脸的时代，你在妹子心中的状态可以用下图描述</p>
<p>{% asset_img tree.png 简单决策树 %}</p>
<p>这样就完成了一个三分类决策树，每一个判断节点都是一个属性，每个节点的分支都是该属性的属性值。</p>
<hr>
<p><strong>决策树学习基本算法</strong></p>
<p>输入：训练集$D = { (\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), &mldr;, (\boldsymbol{x}_m, y_m) }$；</p>
<p>过程：函数$TreeGenerate(D, A)$</p>
<p>01：生成结点$node$；</p>
<p>02：$if$ $D$中样本全属于同一类别$C$ $then$</p>
<p>03： 将$node$标记为$C$类叶结点；$return$</p>
<p>04：$end$ $if$</p>
<p>05：$if$ $A = \emptyset$ $OR$ $D$ 中样本在$A$上的取值相同 $then$</p>
<p>06： 将$node$标记为叶结点，其类别标记为$D$中样本数最多的类；$return$</p>
<p>07：$end$ $if$</p>
<p>08：从$A$中选择最优化分属性$a_k$；</p>
<p>09：$for$ $a_k$的每一个值$a^v_k$ $do$</p>
<p>10： 为$node$生成一个分支；令$D_v$表示$D$中在$a_k$上取值为$a_k^v$的样本子集；</p>
<p>11： $if$ $D_v$为空 $then$</p>
<p>12：  将分支结点标记为叶结点，其标记类别为$D$中样本最多的类；$return$</p>
<p>13： $else$</p>
<p>14：  以$TreeGenerate(D_v, A \setminus {a_k })$为分支结点</p>
<p>15： $end$ $if$</p>
<p>16：$end$ $for$</p>
<p>输出：以$node$为根结点的一棵决策树</p>
<hr>
<p>递归生成决策树有三种情形会导致递归返回：</p>
<ol>
<li>当前结点包含的样本全属于同一类别，无需划分；</li>
<li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；</li>
<li>当前结点包含的样本集合为空，不能划分。</li>
</ol>
<h2 id=2-划分选择>2. 划分选择<a hidden class=anchor aria-hidden=true href=#2-划分选择>#</a></h2>
<p>决策树学习的关键在第8行，即如何选择最优划分属性。一般来说，我们希望分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”也来越高（如何衡量“纯度”，有不同的算法）。</p>
<h3 id=21-信息增益>2.1 信息增益<a hidden class=anchor aria-hidden=true href=#21-信息增益>#</a></h3>
<p>假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k = 1,2,&mldr;,|\mathbb{Y}|)$，则$D$的信息熵定义为</p>
<p>$$
Ent(D) = -\sum^{|\mathbb{Y}|}_{k=1}p_k\log_2p_k
$$</p>
<p>$Ent(D)$的值越小，则$D$的纯度越高。</p>
<p>假定离散属性$a$有$V$个可能的取值${ a^1, a^2, &mldr;,a^V }$，若使用$a$来对样本集合$D$进行划分，则会产生$V$个分支结点，其中第$v$个分支结点包含了$D$中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。则可以计算用属性$a$对$D$进行划分所获得的信息增益</p>
<p>$$
Gain(D, a) = Ent(D) - \sum^V_{v=1}\frac{|D^v|}{|D|}Ent(D^v)
$$</p>
<p>一般而言，信息增益越大，则使用属性$a$来进行划分所获得的纯度提升越大。因此，在第8行使用属性$a_k = \underset{a \in A}{\arg \max Gain(D, a)}$。这就是$ID3$决策树学习算法的划分准则。</p>
<h3 id=22-增益率>2.2 增益率<a hidden class=anchor aria-hidden=true href=#22-增益率>#</a></h3>
<p>利用信息增益作为划分准则可能会带来另一问题，即对可取值数目较多的属性有所偏好，比如说若一个属性有10个属性值，而另一个属性只有3个属性值，此时经过计算很大程度上10个属性值的属性带来的信息增益会大于另一个。为减少这种偏好可能带来的不利影响，$C4.5$决策树算法使用增益率作为划分准则</p>
<p>$$
Gain_ratio(D, a) = \frac{Gain(D,a)}{IV(a)}
\
IV(a) = -\sum^V_{v=1}\frac{|D^v|}{|D|} \log_2\frac{|D^v|}{|D|}
$$</p>
<p>$IV(a)$称为属性$a$的固有值，若属性$a$的取值数目越多，则$IV(a)$的值通常会越大。</p>
<p>与此同时$C4.5$算法具体流程并不是直接选择增益率最高的属性，而是先从候选属性中选择信息增益高于平均水平的属性，再从中选择增益率高的。</p>
<h4 id=23-基尼指数>2.3 基尼指数<a hidden class=anchor aria-hidden=true href=#23-基尼指数>#</a></h4>
<p>$CART$决策树（可用于分类和回归）使用基尼指数选择划分属性</p>
<p>$$
Gini(D) = \sum^{|\mathbb{Y}|}<em>{k=1}\sum</em>{k' \neq k}p_kp_{k'}
\
= 1- \sum^{|\mathbb{Y}|}_{k=1}p_k^2
$$</p>
<p>$Gini(D)$反映了从数据集$D$中随机抽取两个样本，其类别标记不一致的概率。因此，$Gini(D)$越小，则数据集$D$纯度越高。</p>
<p>则对应属性$a$的基尼指数定义为</p>
<p>$$
Gini_index(D, a) = \sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)
$$</p>
<p>我们选择使得划分后基尼指数最小的属性作为最优属性，即</p>
<p>$$
a_k = \underset{a \in A}{\arg \min}Gini_index(D, a)
$$</p>
<h2 id=3-剪枝处理>3. 剪枝处理<a hidden class=anchor aria-hidden=true href=#3-剪枝处理>#</a></h2>
<p>剪枝是对付过拟合的主要手段，主要方式是删除一些分支，基本策略有两种，预剪枝和后剪枝。</p>
<ul>
<li>预剪枝是在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分当前结点并标记为叶结点；</li>
<li>后剪枝是先从数据集生成一棵完整的决策树，然后自底向上对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将子树替换为叶结点。</li>
</ul>
<p>如何判断泛化性能，我们使用验证集进行评估。</p>
<h3 id=31-预剪枝>3.1 预剪枝<a hidden class=anchor aria-hidden=true href=#31-预剪枝>#</a></h3>
<p>{% asset_img precut.png 预剪枝 %}</p>
<ol>
<li>根据划分准则选择最优划分属性；</li>
<li>计算不对当前最优属性划分的条件下验证集的准确率；</li>
<li>计算对当前最优属性划分后验证集的准确率；</li>
<li>比较上面两步的值，若划分后的准确率不大于划分前，则放弃使用该属性划分。</li>
</ol>
<p>优劣：</p>
<ul>
<li>预剪枝是基于贪心算法的，必然存在继续划分可能带来泛化性能提升的可能性，使用预剪枝导致永远无法展开这些分支；</li>
<li>预剪枝降低过拟合的风险，减少了训练开销。</li>
</ul>
<h3 id=32-后剪枝>3.2 后剪枝<a hidden class=anchor aria-hidden=true href=#32-后剪枝>#</a></h3>
<p>{% asset_img backcut.png 后剪枝 %}</p>
<ol>
<li>根据训练集生成完整的决策树；</li>
<li>计算当前决策树在验证集上的准确率；</li>
<li>自底向上考虑某个属性，计算将当前属性替换为叶结点（取最多的类别作为叶结点标记）后的验证集准确率；</li>
<li>比较上面两步的值，若剪枝后的准确率不大于剪枝前的，则放弃使用该属性划分。</li>
</ol>
<p>优劣：</p>
<ul>
<li>后剪枝保留的分支较预剪枝多，所以欠拟合风险小，泛化性能优于预剪枝；</li>
<li>自底向上的过程导致训练开销远大于预剪枝。</li>
</ul>
<h2 id=4-连续与缺失值>4. 连续与缺失值<a hidden class=anchor aria-hidden=true href=#4-连续与缺失值>#</a></h2>
<h3 id=41-连续值处理>4.1 连续值处理<a hidden class=anchor aria-hidden=true href=#41-连续值处理>#</a></h3>
<p>对于连续值，最简单的策略是采用二分法，即将属性$a$的属性值基于$t$划分为两个阵营$D_t^-$和$D_t^+$，如何确定$t$的值才能使该划分为最优化分，显然，$t$的取值在$[a^i, a^{i+1})$之间都是等效的，那么我们可以参照插队的方式取$t$的所有可能值，再从中选取最优点。</p>
<p>对于有$n$个属性值的连续属性$a$，$t$的候选划分点集和</p>
<p>$$
T_a = { \frac{a^i + a^{i+1}}{2}|1 \leqslant i \leqslant n-1 }
$$</p>
<p>通过对信息增益表达式的改造</p>
<p>$$
Gain(D, a) = \underset{t \in T_a}{\max} Gain(D, a, t)
\
= \underset{t \in T_a}{\max} Ent(D) - \sum_{\lambda \in { -,+ }}\frac{|D^{\lambda}_t|}{|D|}Ent(D_t^{\lambda})
$$</p>
<p>需注意的是，与离散属性不同，若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性。</p>
<h3 id=42-缺失值处理>4.2 缺失值处理<a hidden class=anchor aria-hidden=true href=#42-缺失值处理>#</a></h3>
<p>样本不完整，那么该样本应该怎样划分呢。</p>
<p>问题等价于</p>
<ol>
<li>如何在属性缺失的情况下进行划分属性选择？</li>
<li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？</li>
</ol>
<p>比较简单的方式是根据数据集$D$中在属性$a$上没有缺失值的样本来对属性$a$进行划分。</p>
<hr>
<p>对问题（1），令$\tilde{D}$表示$D$在属性$a$上没有缺失值的样本子集，
假定属性$a$有$V$个可取值${ a^1, a^2,&mldr;,a^V }$，
令$\tilde{D}^v$表示$\tilde{D}$中在属性$a$上取值为$a^v$的样本子集，
$\tilde{D}<em>k$表示$\tilde{D}$中属于第$k$类（$k = 1, 2,&mldr;,|\mathbb{Y}|$）的样本子集，则显然有$\tilde{D} = \bigcup</em>{k=1}^{|\mathbb{Y}|}\tilde{D}<em>k = \bigcup</em>{v=1}^{|V|}\tilde{D}^v$。
假定为每个样本$\boldsymbol{x}$初始化一个权重$w_{\boldsymbol{x}}$（初始值全为1），并定义</p>
<p>$$
\rho = \frac{\sum_{\boldsymbol{x}\in \tilde{D}}w_{\boldsymbol{x}}}{\sum_{\boldsymbol{x}\in D}w_{\boldsymbol{x}}}
\
\tilde{p}<em>k = \frac{\sum</em>{\boldsymbol{x}\in \tilde{D}<em>k}w</em>{\boldsymbol{x}}}{\sum_{\boldsymbol{x}\in \tilde{D}}w_{\boldsymbol{x}}}
\
\tilde{r}<em>v = \frac{\sum</em>{\boldsymbol{x}\in \tilde{D}^v}w_{\boldsymbol{x}}}{\sum_{\boldsymbol{x}\in \tilde{D}}w_{\boldsymbol{x}}}
$$</p>
<p>对属性$a$来说，$\rho$表示无缺失值样本所占的比例，$\tilde{p}_k$表示无缺失值样本中第$k$类所占的比例，$\tilde{r}<em>v$则表示无缺失值样本在属性$a$上取值$a^v$的样本所占的比例。显然$\sum^{|\mathbb{Y}|}</em>{k=1}\tilde{p}<em>k=1,\sum^V</em>{v=1}\tilde{r}_v=1$。</p>
<p>基于上述定义，信息增益计算式可推广为</p>
<p>$$
Gain(D, a) = \rho \times Gain(\tilde{D}, a)
\
= \rho \times { Ent(\tilde{D}) - \sum^V_{v=1}\tilde{r}_vEnt(\tilde{D}^v) }
$$</p>
<p>其中</p>
<p>$$
Ent(\tilde{D}) = - \sum^{|\mathbb{Y}|}_{k=1}\tilde{p}_k\log_2\tilde{p}_k
$$</p>
<hr>
<p>对问题（2）,若样本$\boldsymbol{x}$在划分属性$a$上的取值已知，则将$\boldsymbol{x}$划入与其取值对应的子结点，且样本权值保持为$w_{\boldsymbol{x}}$。
若样本$\boldsymbol{x}$在划分属性$a$上的取值未知，则将$\boldsymbol{x}$同时划入所有子结点，且样本权值在与属性$a^v$对应的子结点中调整为$\tilde{r} \cdot w_{\boldsymbol{x}}$；
直观地看，这就是让同一个样本以不同的概率划入到不同的子结点中去。</p>
<h2 id=5-多变量决策树>5. 多变量决策树<a hidden class=anchor aria-hidden=true href=#5-多变量决策树>#</a></h2>
<p>使用单属性作为划分结点，我们得到的决策树的分类边界是平行于该属性对应的轴。</p>
<p>{% asset_img tree1.png 决策树对应分类边界 %}</p>
<p>但在现实任务中，我们希望分类边界尽可能平滑，越平滑意味着每个结点包含的分类标准越复杂，需要的属性组合就越多，所以我们希望能以局部线性拟合平滑曲线，这就是多变量决策树</p>
<p>{% asset_img tree3.png 决策树对复杂分类边界的分段近似 %}</p>
<p>在多变量决策树中，每个非叶结点不再是仅对某个属性，而是对属性的线性组合进行测试；换言之，每个非叶结点是一个形如$\sum^d_{i=1}w_ia_i=t$的线性分类器，其中$w_i$是属性$a_i$的权重，$w_i,t$可在该结点所含的样本集和属性集上学得。于是，多变量决策树的训练过程就不是寻找最优划分属性，而是建立一个合适的线性分类器。</p>
<p>{% asset_img tree2.png 多变量决策树对应的分类边界 %}</p>
<h2 id=6-回归树>6. 回归树<a hidden class=anchor aria-hidden=true href=#6-回归树>#</a></h2>
<p>{% asset_img 0.png %}</p>
<p>分类决策树处理的是分类问题，其特点是target是label标签，而标签是一个有限集，因此决策树的构建需要在叶结点判断标签，最终也只需要判断准确率即可，分类节点使用信息增益相关的算法即可；
回归树处理的是回归问题，即最终的目标是一个预测值，而我们的训练数据的真实值可以说是无穷多的，因此只能用误差损失来衡量，比如用平方误差衡量单个样本的误差。而每个结点（不只是叶结点）都对应一个预测值，这个预测值的大小是被分配到这个结点的所有样本的真实值的均值，如何选择最优属性以及最优划分阈值可以参考上面<code>4. 连续与缺失值</code>。</p>
<p>{% asset_img 1.png %}</p>
<h2 id=7-思考>7. 思考<a hidden class=anchor aria-hidden=true href=#7-思考>#</a></h2>
<ul>
<li>决策树是最接近人类思考的最简单的模型，讲道理在大多数情况下，我们所做的每一个行为都是基于各种细小属性的决策，那么是否有一种复杂多变量决策树可以动态的描述一个人或者生物的行为呢，与此同时，每一个分类结点的权重也是一个变量，其收到其他因素的影响。显然，这种想法会导致维度爆炸。</li>
<li>换一种思路，我们基于某种主干决策树做大多数决策，同时存在偏差决策树，偏差决策树构成森林，根据主干与偏差的相互叠加，我们完成其他的行为决策。</li>
<li>基于决策树的其他算法框架在分类任务中具有极好的效果，比如<code>XGBoost</code>、<code>GBDT</code>、<code>Random Forest</code>，接下来会思考这些算法。</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhuantou233.github.io/tags/theory/>Theory</a></li>
<li><a href=https://zhuantou233.github.io/tags/decision-tree/>Decision Tree</a></li>
<li><a href=https://zhuantou233.github.io/tags/regression-decision-tree/>Regression Decision Tree</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhuantou233.github.io/posts/second/>
<span class=title>« Prev Page</span>
<br>
<span>Second blog test</span>
</a>
</nav>
</footer>
<script src=https://utteranc.es/client.js repo=zhuantou233/zhuantou233.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zhuantou233.github.io/>ExampleSite</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>